package main

import (
	"bytes"
	"reflect"
	"regexp"
	"testing"
)

func Test_generateFile(t *testing.T) {
	tests := []struct {
		name    string
		kind    string
		path    string
		pointer bool
		skip    string
		want    []byte
	}{
		{name: "foo", kind: "Foo", path: "./testdata", want: []byte(FooFile)},
		{name: "foo - pointer", kind: "Foo", pointer: true, path: "./testdata", want: []byte(FooPointerFile)},
		{name: "foo - pointer, skip slice", kind: "Foo", pointer: true, skip: "Slice", path: "./testdata", want: []byte(FooPointerSkipSliceFile)},
		{name: "alpha - with DeepCopy method", kind: "Alpha", path: "./testdata", want: []byte(AlphaPointer)},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := run(tt.path, tt.kind, tt.skip, tt.pointer)
			if err != nil {
				t.Fatal(err)
			}
			got = normalizeComment(got)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("generateFile() = %v, want %v", string(got), string(tt.want))
			}
		})
	}
}

var re = regexp.MustCompile(`generated by .*deep-copy.* !DO NOT EDIT!`)

func normalizeComment(in []byte) []byte {
	return re.ReplaceAll(bytes.TrimSpace(in), []byte("generated by deep-copy !DO NOT EDIT!"))
}

const (
	FooFile = `// generated by deep-copy !DO NOT EDIT!

package testdata

// DeepCopy generates a deep copy of Foo
func (o Foo) DeepCopy() Foo {
	var cp Foo
	cp = o
	if o.Map != nil {
		cp.Map = make(map[string]*Bar, len(o.Map))
		for k, v := range o.Map {
			var cpv *Bar
			if v != nil {
				cpv = new(Bar)
				*cpv = *v
				if v.Slice != nil {
					cpv.Slice = make([]string, len(v.Slice))
					copy(cpv.Slice, v.Slice)
				}
			}
			cp.Map[k] = cpv
		}
	}
	if o.ch != nil {
		cp.ch = make(chan float32, cap(o.ch))
	}
	if o.baz.StringPointer != nil {
		cp.baz.StringPointer = new(string)
		*cp.baz.StringPointer = *o.baz.StringPointer
	}
	return cp
}`
	FooPointerFile = `// generated by deep-copy !DO NOT EDIT!

package testdata

// DeepCopy generates a deep copy of *Foo
func (o *Foo) DeepCopy() *Foo {
	var cp Foo
	cp = *o
	if o.Map != nil {
		cp.Map = make(map[string]*Bar, len(o.Map))
		for k, v := range o.Map {
			var cpv *Bar
			if v != nil {
				cpv = new(Bar)
				*cpv = *v
				if v.Slice != nil {
					cpv.Slice = make([]string, len(v.Slice))
					copy(cpv.Slice, v.Slice)
				}
			}
			cp.Map[k] = cpv
		}
	}
	if o.ch != nil {
		cp.ch = make(chan float32, cap(o.ch))
	}
	if o.baz.StringPointer != nil {
		cp.baz.StringPointer = new(string)
		*cp.baz.StringPointer = *o.baz.StringPointer
	}
	return &cp
}`
	FooPointerSkipSliceFile = `// generated by deep-copy !DO NOT EDIT!

package testdata

// DeepCopy generates a deep copy of *Foo
func (o *Foo) DeepCopy() *Foo {
	var cp Foo
	cp = *o
	if o.Map != nil {
		cp.Map = make(map[string]*Bar, len(o.Map))
		for k, v := range o.Map {
			var cpv *Bar
			if v != nil {
				cpv = new(Bar)
				*cpv = *v
			}
			cp.Map[k] = cpv
		}
	}
	if o.ch != nil {
		cp.ch = make(chan float32, cap(o.ch))
	}
	if o.baz.StringPointer != nil {
		cp.baz.StringPointer = new(string)
		*cp.baz.StringPointer = *o.baz.StringPointer
	}
	return &cp
}`
	AlphaPointer = `// generated by deep-copy !DO NOT EDIT!

package testdata

// DeepCopy generates a deep copy of Alpha
func (o Alpha) DeepCopy() Alpha {
	var cp Alpha
	cp = o
	if o.B != nil {
		cp.B = o.B.DeepCopy()
	}
	cp.G = o.G.DeepCopy()
	if o.D != nil {
		retV := o.D.DeepCopy()
		cp.D = &retV
	}
	{
		retV := o.E.DeepCopy()
		cp.E = *retV
	}
	return cp
}`
)
