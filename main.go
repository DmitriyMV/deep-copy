package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"io"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeF            = flag.String("type", "", "the concrete type")
	pointerReceiverF = flag.Bool("pointer-receiver", false, "the generated receiver type")
)

func main() {
	flag.Parse()

	if *typeF == "" {
		log.Fatalln("no type given")
	}

	packages, err := load(flag.Args()...)
	if err != nil {
		log.Fatalln("Error loading packages", err)
	}

	sel := *typeF

	var buf bytes.Buffer

	var ptr string
	if *pointerReceiverF {
		ptr = "*"
	}
	fmt.Fprintf(&buf, `// DeepCopy generates a deep copy of %s%s
func (o %s%s) DeepCopy() %s%s {
	var cp %s
`, ptr, sel, ptr, sel, ptr, sel, sel)

	imports := map[string]string{}
	var name string
	for _, p := range packages {
		name = p.Name
		obj, err := locateType(name, sel, p)
		if err != nil {
			log.Fatalln("locating type", err)
		}

		sink := "o"
		fmt.Fprintf(&buf, "cp = %s%s\n", ptr, sink)
		walkType(sink, "cp", name, obj, &buf, imports)
	}

	if name == "" {
		log.Fatalln("No package found")
	}

	if *pointerReceiverF {
		buf.WriteString("return &cp\n}")
	} else {
		buf.WriteString("return cp\n}")
	}

	var file bytes.Buffer

	fmt.Fprintf(&file, "// generated by %s !DO NOT EDIT!\n\npackage %s\n\n", strings.Join(os.Args, " "), name)

	if len(imports) > 0 {
		file.WriteString("import (\n")
		for name, path := range imports {
			if strings.HasSuffix(path, name) {
				fmt.Fprintf(&file, "%q\n", path)
			} else {
				fmt.Fprintf(&file, "%s %q\n", name, path)
			}
		}
		file.WriteString(")\n")
	}

	buf.WriteTo(&file)

	b, err := format.Source(file.Bytes())
	if err != nil {
		log.Fatalln("Error formatting result:", err)
	}
	os.Stdout.Write(b)
}

func load(patterns ...string) ([]*packages.Package, error) {
	return packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedDeps | packages.NeedImports,
	}, patterns...)
}

type Object interface {
	types.Type
	Obj() *types.TypeName
}

type Pointer interface {
	Elem() types.Type
}

func locateType(x, sel string, p *packages.Package) (Object, error) {
	for _, t := range p.TypesInfo.Types {
		m := exprFilter(t, sel, x)
		if m == nil {
			continue
		}

		return m, nil
	}

	return nil, errors.New("type not found")
}

func objFromType(typ types.Type) Object {
	if pointer, ok := typ.(Pointer); ok {
		typ = pointer.Elem()
	}

	m, ok := typ.(Object)
	if !ok {
		return nil
	}

	return m
}

func exprFilter(t types.TypeAndValue, sel string, x string) Object {
	m := objFromType(t.Type)
	if m == nil {
		return nil
	}

	obj := m.Obj()
	if obj.Pkg() == nil || x != obj.Pkg().Name() || sel != obj.Name() {
		return nil
	}

	return m
}

func walkType(source, sink, x string, m types.Type, w io.Writer, imports map[string]string) {
	if m == nil {
		return
	}

	var needExported bool
	switch v := m.(type) {
	case *types.Named:
		if v.Obj().Pkg() != nil && v.Obj().Pkg().Name() != x {
			needExported = true
		}
	}

	under := m.Underlying()
	switch v := under.(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			field := v.Field(i)
			if needExported && !field.Exported() {
				continue
			}
			walkType(source+"."+field.Name(), sink+"."+field.Name(), x, field.Type(), w, imports)
		}
	case *types.Slice:
		obj := objFromType(v.Elem())
		_, pointer := v.Elem().(*types.Pointer)
		var name, kind string

		if pointer {
			kind = "*"
		}
		if obj != nil {
			pkg := obj.Obj().Pkg()
			if pkg != nil {
				name = pkg.Name()
				if name == x {
					name = ""
				} else {
					if path, ok := imports[name]; ok && path != pkg.Path() {
						name = strings.ReplaceAll(pkg.Path(), "/", "_")
					}
					imports[name] = pkg.Path()
					kind += name + "."
				}
			}
			kind += obj.Obj().Name()
		} else {
			kind += v.Elem().String()
		}

		fmt.Fprintf(w, `if %s != nil {
	%s = make([]%s, len(%s))
	copy(%s, %s)
}
`, source, sink, kind, source, sink, source)
	case *types.Pointer:
		obj := objFromType(v.Elem())
		var name, kind string
		if obj != nil {
			pkg := obj.Obj().Pkg()
			if pkg != nil {
				name = pkg.Name()
				if name == x {
					name = ""
				} else {
					if path, ok := imports[name]; ok && path != pkg.Path() {
						name = strings.ReplaceAll(pkg.Path(), "/", "_")
					}
					imports[name] = pkg.Path()
					kind += name + "."
				}
			}
			kind += obj.Obj().Name()
		} else {
			kind += v.Elem().String()
		}

		fmt.Fprintf(w, `if %s != nil {
	%s = new(%s)
	*%s = *%s
`, source, sink, kind, sink, source)

		walkType(source, sink, x, v.Elem(), w, imports)

		fmt.Fprintf(w, "}\n")
	}

}
