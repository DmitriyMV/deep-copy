package main

import (
	"bytes"
	"errors"
	"flag"
	"fmt"
	"go/format"
	"go/types"
	"io"
	"log"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"
)

var (
	typeF            = flag.String("type", "", "the concrete type")
	pointerReceiverF = flag.Bool("pointer-receiver", false, "the generated receiver type")
	skipF            = flag.String("skip", "", "comma-separated field selectors to shallow copy")
)

func main() {
	flag.Parse()

	if *typeF == "" {
		log.Fatalln("no type given")
	}

	if flag.NArg() != 1 {
		log.Fatalln("No package path given")
	}

	packages, err := load(flag.Args()[0])
	if err != nil {
		log.Fatalln("Error loading packages", err)
	}
	if len(packages) == 0 {
		log.Fatalln("No package found")
	}

	fn, imports, err := generateFunc(packages[0], *typeF, *pointerReceiverF, *skipF)
	if err != nil {
		log.Fatalln("Error generating method:", err)
	}

	b, err := generateFile(packages[0], fn, imports)
	if err != nil {
		log.Fatalln("Error generating file content:", err)
	}

	os.Stdout.Write(b)
}

func load(patterns string) ([]*packages.Package, error) {
	return packages.Load(&packages.Config{
		Mode: packages.NeedName | packages.NeedFiles | packages.NeedTypes | packages.NeedTypesInfo | packages.NeedDeps | packages.NeedImports,
	}, patterns)
}

func generateFunc(p *packages.Package, kind string, pointer bool, skip string) ([]byte, map[string]string, error) {
	var buf bytes.Buffer

	var ptr string
	if pointer {
		ptr = "*"
	}
	fmt.Fprintf(&buf, `// DeepCopy generates a deep copy of %s%s
func (o %s%s) DeepCopy() %s%s {
	var cp %s
`, ptr, kind, ptr, kind, ptr, kind, kind)

	skips := map[string]struct{}{}
	for _, s := range strings.Split(skip, ",") {
		skips[s] = struct{}{}
	}

	imports := map[string]string{}
	name := p.Name
	obj, err := locateType(name, kind, p)
	if err != nil {
		return nil, nil, err
	}

	sink := "o"
	fmt.Fprintf(&buf, "cp = %s%s\n", ptr, sink)
	walkType(sink, "cp", name, obj, &buf, imports, skips)

	if pointer {
		buf.WriteString("return &cp\n}")
	} else {
		buf.WriteString("return cp\n}")
	}

	return buf.Bytes(), imports, nil
}

func generateFile(p *packages.Package, fn []byte, imports map[string]string) ([]byte, error) {
	var file bytes.Buffer

	fmt.Fprintf(&file, "// generated by %s !DO NOT EDIT!\n\npackage %s\n\n", strings.Join(os.Args, " "), p.Name)

	if len(imports) > 0 {
		file.WriteString("import (\n")
		for name, path := range imports {
			if strings.HasSuffix(path, name) {
				fmt.Fprintf(&file, "%q\n", path)
			} else {
				fmt.Fprintf(&file, "%s %q\n", name, path)
			}
		}
		file.WriteString(")\n")
	}

	file.Write(fn)

	b, err := format.Source(file.Bytes())
	if err != nil {
		return nil, err
	}

	return b, nil
}

type Object interface {
	types.Type
	Obj() *types.TypeName
}

type Pointer interface {
	Elem() types.Type
}

func locateType(x, sel string, p *packages.Package) (Object, error) {
	for _, t := range p.TypesInfo.Defs {
		if t == nil {
			continue
		}
		m := exprFilter(t.Type(), sel, x)
		if m == nil {
			continue
		}

		return m, nil
	}

	return nil, errors.New("type not found")
}

func objFromType(typ types.Type) Object {
	if pointer, ok := typ.(Pointer); ok {
		typ = pointer.Elem()
	}

	m, ok := typ.(Object)
	if !ok {
		return nil
	}

	return m
}

func exprFilter(t types.Type, sel string, x string) Object {
	m := objFromType(t)
	if m == nil {
		return nil
	}

	obj := m.Obj()
	if obj.Pkg() == nil || x != obj.Pkg().Name() || sel != obj.Name() {
		return nil
	}

	return m
}

func walkType(source, sink, x string, m types.Type, w io.Writer, imports map[string]string, skips map[string]struct{}) {
	if m == nil {
		return
	}

	var needExported bool
	switch v := m.(type) {
	case *types.Named:
		if v.Obj().Pkg() != nil && v.Obj().Pkg().Name() != x {
			needExported = true
		}
	}

	under := m.Underlying()
	switch v := under.(type) {
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			field := v.Field(i)
			if needExported && !field.Exported() {
				continue
			}
			fname := field.Name()
			sel := sink + "." + fname
			sel = sel[strings.Index(sel, ".")+1:]
			if _, ok := skips[sel]; ok {
				continue
			}
			walkType(source+"."+fname, sink+"."+fname, x, field.Type(), w, imports, skips)
		}
	case *types.Slice:
		kind, basic := getElemType(v.Elem(), x, imports, false)

		if basic {
			fmt.Fprintf(w, `if %s != nil {
	%s = make([]%s, len(%s))
	copy(%s, %s)
}
`, source, sink, kind, source, sink, source)
		} else {
			fmt.Fprintf(w, `if %s != nil {
	%s = make([]%s, len(%s))
	for i := range %s {
`, source, sink, kind, source, source)

			walkType(source+"[i]", sink+"[i]", x, v.Elem(), w, imports, skips)

			fmt.Fprintf(w, "}\n}\n")
		}
	case *types.Pointer:
		kind, _ := getElemType(v.Elem(), x, imports, true)

		fmt.Fprintf(w, `if %s != nil {
	%s = new(%s)
	*%s = *%s
`, source, sink, kind, sink, source)

		walkType(source, sink, x, v.Elem(), w, imports, skips)

		fmt.Fprintf(w, "}\n")
	case *types.Chan:
		kind, _ := getElemType(v.Elem(), x, imports, false)

		fmt.Fprintf(w, `if %s != nil {
	%s = make(chan %s, cap(%s))
}
`, source, sink, kind, source)
	case *types.Map:
		kkind, kbasic := getElemType(v.Key(), x, imports, false)
		vkind, vbasic := getElemType(v.Elem(), x, imports, false)

		fmt.Fprintf(w, `if %s != nil {
	%s = make(map[%s]%s, len(%s))
	for k, v := range %s {
`, source, sink, kkind, vkind, source, source)

		ksink, vsink := "k", "v"
		if !kbasic {
			ksink = "cpk"
			fmt.Fprintf(w, "var %s %s\n", ksink, kkind)
			walkType("k", ksink, x, v.Key(), w, imports, skips)
		}
		if !vbasic {
			vsink = "cpv"
			fmt.Fprintf(w, "var %s %s\n", vsink, vkind)
			walkType("v", vsink, x, v.Elem(), w, imports, skips)
		}

		fmt.Fprintf(w, "%s[%s] = %s", sink, ksink, vsink)

		fmt.Fprintf(w, "}\n}\n")
	}

}

func getElemType(t types.Type, x string, imports map[string]string, rawkind bool) (string, bool) {
	obj := objFromType(t)
	var name, kind string
	if obj != nil {
		pkg := obj.Obj().Pkg()
		if pkg != nil {
			name = pkg.Name()
			if name == x {
				name = ""
			} else {
				if path, ok := imports[name]; ok && path != pkg.Path() {
					name = strings.ReplaceAll(pkg.Path(), "/", "_")
				}
				imports[name] = pkg.Path()
				kind += name + "."
			}
		}
		kind += obj.Obj().Name()
	} else {
		kind += t.String()
	}

	var pointer, noncopy bool
	switch t.(type) {
	case *types.Pointer:
		pointer = true
	case *types.Basic, *types.Interface:
		noncopy = true
	}

	if !rawkind && pointer && kind[0] != '*' {
		kind = "*" + kind
	}

	return kind, noncopy
}
